# create_image.py

from PIL import Image, ImageFont, ImageDraw
import pandas as pd
import plotly.graph_objects as go
import plotly.io as pio
from sqlalchemy import create_engine, Column, String, Integer, Float, Text
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from dotenv import load_dotenv
import os
import keyboard

def overlay_text(img, text, position, font, color):
    """
    Overlays the given text on the provided image at the specified position.
    """
    draw = ImageDraw.Draw(img)
    draw.text(position, text, font=font, fill=color)


def update_data():
    # Reopen the session to ensure new data is captured
    Session = sessionmaker(bind=engine)
    session = Session()

    # Get current data from the database and convert it to a DataFrame
    database = session.query(Earthquake).all()
    data = [item.__dict__ for item in database]
    
    # Remove the _sa_instance_state key generated by SQLAlchemy
    for item in data:
        item.pop('_sa_instance_state', None)
    db_df = pd.DataFrame(data)
    session.close()
    return db_df


def roman_to_int(roman_str):
    roman_numerals = {
        'I': 1, 'II': 2, 'III': 3, 'IV': 4, 'V': 5,
        'VI': 6, 'VII': 7, 'VIII': 8, 'IX': 9, 'X': 10
    }
    value = roman_numerals.get(roman_str)
    return value

# Function to convert intensity ranges into an average value
def parse_intensity(intensity_all):
    result = []
    # Detect if it's a range or a single value
    for intensity in intensity_all:
        if '/' in intensity:
            parts = intensity.split('/')
            values = [roman_to_int(part) for part in parts]
            result.append(int(sum(values) / 2))  # Returns the average of the values
        elif 'Sem info' in intensity:
            return 1 # Default value
        else:
            result.append(int(roman_to_int(intensity)))  # Returns the integer value
    return result

def create_map_image(df):
    """
    Create a map image with earthquake data and save it as an image file.
    """
    try:
        # Set Mapbox token
        pio.kaleido.scope.mapbox_access_token = token_mapbox

        # Define custom color scale
        custom_colors = [
            "#006400",  # Green
            "#00FF00",  # Lime
            "#ffbf00",  # Yellow
            "#ff4000",  # Orange
            "#ff0000",  # Red
        ]

        # Create Plotly map figure
        image = go.Figure()
        image.add_trace(go.Scattermapbox(
            lat=df['latitude'],
            lon=df['longitude'],
            mode='markers',
            marker=dict(
                size=(df['scale'] ** 2.5) + 5,  # Marker size
                color=parse_intensity(df['intensity']),  # Color based on intensity
                colorscale=custom_colors,  # Custom colorscale
                colorbar=dict(
                    tickvals=[1, 10],  # Color range values
                    ticktext=['1', '10'],  # Color range labels
                    title='Intensity'  # Color bar title
                ),
                cmin=1,  # Minimum value for color scale
                cmax=10,  # Maximum value for color scale
                showscale=True  # Show color scale
            )
        ))

        # Update layout for the map
        image.update_layout(
            mapbox=dict(
                style="mapbox://styles/mapbox/outdoors-v12",  # Check if this is valid
                center=dict(lat=df['latitude'].iloc[-1], lon=df['longitude'].iloc[-1]),  # Center the map
                zoom=10  # Zoom level
            ),
            margin=dict(r=0, t=0, l=0, b=0)  # Remove margins
        )

        # Save the image
        image.write_image("assets/MAPA_SISMO.png", width=1080, height=1080)

        # Open the saved image to add a border
        img = Image.open("assets/MAPA_SISMO.png")
        draw = ImageDraw.Draw(img)

        # Define border parameters
        xy_1 = (455, 500)  # Top-left corner
        xy_2 = (535, 580)  # Bottom-right corner
        outline_color = 'red'
        outline_width = 5

        # Draw the border
        draw.line([xy_1[0], xy_1[1], xy_2[0], xy_1[1]], fill=outline_color, width=outline_width)  # Top
        draw.line([xy_2[0], xy_1[1], xy_2[0], xy_2[1]], fill=outline_color, width=outline_width)  # Right
        draw.line([xy_2[0], xy_2[1], xy_1[0], xy_2[1]], fill=outline_color, width=outline_width)  # Bottom
        draw.line([xy_1[0], xy_2[1], xy_1[0], xy_1[1]], fill=outline_color, width=outline_width)  # Left

        # Save the final image
        img.save("assets/MAPA_SISMO.png")

    except Exception as e:
        print(f"An error occurred while creating the map image: {e}")
if __name__ == "__main__":
    # Load sensitive information
    load_dotenv('.env')
    host = os.getenv('host')
    user = os.getenv('user')
    password = os.getenv('password')
    database = os.getenv('database')
    token_mapbox = os.getenv('token_mapbox')

    Base = declarative_base()
    class Earthquake(Base):
        __tablename__ = "earthquake"
        id = Column("id", Integer, primary_key=True, autoincrement="auto")
        title = Column("title", Text)
        description = Column("description", Text)
        pub_date = Column("publication_date", String(25))
        date = Column("date_time", String(50))
        scale = Column("scale", Float)
        location = Column("location", String(255))
        intensity = Column("intensity", String(255))
        latitude = Column("latitude", Float)
        longitude = Column('longitude', Float)

        def __init__(self, id, title, description, pub_date, date, scale, location, intensity, latitude, longitude):
            self.id = id
            self.title = title
            self.description = description
            self.pub_date = pub_date
            self.date = date
            self.scale = scale
            self.location = location
            self.intensity = intensity
            self.latitude = latitude
            self.longitude = longitude

        def __repr__(self):
            return f"({self.id}) ({self.title}) ({self.description}) ({self.pub_date}) ({self.date}) ({self.scale}) ({self.location}) ({self.intensity}) ({self.latitude}) ({self.longitude})"


    # Establishes the connection to the server
    engine = create_engine(f"mysql+pymysql://{user}:{password}@{host}/{database}?charset=utf8mb4")
    Base = declarative_base()
    latest_data = update_data()
    latest_data = latest_data.drop(latest_data.index[-1])
    latest_data = latest_data.iloc[-1]
    while True:
        data = update_data()
        if not data.iloc[-1].equals(latest_data) or (keyboard.is_pressed('s')): 
            # Get the latest data of database
            latest_data = update_data().iloc[-1]
            
            # Create map image with earthquake
            create_map_image(update_data())

            # Load the image template
            img_path = "assets/SISMO_TEMPLATE_AUTO.png"
            img = Image.open(img_path)

            # Define the font for the overlay text
            font = ImageFont.truetype("assets/Lato-Bold.ttf", 38)

            # Overlay the location information on the image
            location_text = str(latest_data['location'][0]).upper() + str(latest_data['location'][1:])
            overlay_text(img, location_text, (390, 559), font, "#703D25")

            # Overlay the scale information on the image
            scale_text = str(latest_data['scale'])
            overlay_text(img, scale_text, (455, 629), font, "#703D25")

            # Overlay the date_time information on the image
            date_time_text = latest_data['pub_date']
            overlay_text(img, date_time_text, (242, 772), font, "#00A396")

            # Overlay the intensity information on the image
            intensity_text = latest_data['intensity']
            overlay_text(img, intensity_text, (520, 832), font, "#703D25")

            # Create new white image
            img_final = Image.new("RGB", (2160, 1080), color="white")

            # Get the map image with earthquake
            img_path = "assets/MAPA_SISMO.png"
            img_map = Image.open(img_path)

            # Place the two images on the white image
            img_final.paste(img, (0, 0))
            img_final.paste(img_map, (1080, 0))

            # Save the modified final image
            img_final.save("assets/SISMO_TWEET.png")

            print("Imagem final criada!\nA enviar para as redes!")