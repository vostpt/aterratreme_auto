import dash
from dash import dcc, html
from dash.dependencies import Input, Output
import pandas as pd
import plotly.express as px
from sqlalchemy import create_engine, Column, String, Integer, Float, Text
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from dotenv import load_dotenv
import os

def update_data():
    # Reopen the session to ensure new data is captured
    Session = sessionmaker(bind=engine)
    session = Session()

    # Get current data from the database and convert it to a DataFrame
    database = session.query(Earthquake).all()
    data = [item.__dict__ for item in database]
    
    # Remove the _sa_instance_state key generated by SQLAlchemy
    for item in data:
        item.pop('_sa_instance_state', None)
    
    db_df = pd.DataFrame(data)
    session.close()
    return db_df

Base = declarative_base()
class Earthquake(Base):
    __tablename__ = "earthquake"
    id = Column("id", Integer, primary_key=True, autoincrement="auto")
    title = Column("title", Text)
    description = Column("description", Text)
    pub_date = Column("publication_date", String(25))
    date = Column("date_time", String(50))
    scale = Column("scale", Float)
    location = Column("location", String(255))
    intensity = Column("intensity", String(255))
    latitude = Column("latitude", Float)
    longitude = Column('longitude', Float)

    def __init__(self, id, title, description, pub_date, date, scale, location, intensity, latitude, longitude):
        self.id = id
        self.title = title
        self.description = description
        self.pub_date = pub_date
        self.date = date
        self.scale = scale
        self.location = location
        self.intensity = intensity
        self.latitude = latitude
        self.longitude = longitude

    def __repr__(self):
        return f"({self.id}) ({self.title}) ({self.description}) ({self.pub_date}) ({self.date}) ({self.scale}) ({self.location}) ({self.intensity}) ({self.latitude}) ({self.longitude})"

# Title of APP
title = "AterraTreme Dashboard"

# Initialize the Dash application
app = dash.Dash(__name__)
app.title = title

# Load sensitive information
load_dotenv('.env')
host = os.getenv('host')
user = os.getenv('user')
password = os.getenv('password')
database = os.getenv('database')

# Establishes the connection to the server
engine = create_engine(f"mysql+pymysql://{user}:{password}@{host}/{database}?charset=utf8mb4")
Base = declarative_base()

# Layout of the Dash app
app.layout = html.Div(
    style={"background-color":"white", "font-family" : "sans-serif", "display" : "flex", "width":"97vw", "overflow": "hidden"},
    children=[
        html.Div(
            style={"background-color":"black", "width":"28vw", "padding-left":"5px", "padding-right":"5px"},
            children=[
                html.Div(
                    style={"color" : "white"},
                    children=[
                        html.H1(title)
                    ]
                ),
                # Dropdown for title selection
                dcc.Dropdown(
                    id='title-dropdown',
                    options=[],
                    value=None,  # Initial value
                    style={"width": "100%"}
                ),
                html.Br(),
                # Div to display description and publication date
                html.Div(id='description-date', style={"color" : "white"}),
                html.Br(),
                dcc.Markdown(
                    style={"color" : "white"},
                    children=[
                        '''
                        #### Dados extra√≠dos do [IPMA](https://www.ipma.pt)
                        '''
                    ]
                )
            ]
        ),
        html.Div(
            id='map-container',
            style={"height":"100vh"},
            children=[
                # Map to show the location of earthquakes
                dcc.Graph(id='map', style={"height":"100vh", "width":"65.5vw"}),
            ]
        ),
        # Interval to update the data
        dcc.Interval(
            id='interval-component',
            interval=60*1000,  # Update every minute
            n_intervals=0
        )
    ]
)

# Callback to update the dropdown options and the map
@app.callback(
    [Output('title-dropdown', 'options'),
     Output('title-dropdown', 'value'),
     Output('map', 'figure')],
    [Input('interval-component', 'n_intervals')]
)
def update_dropdown_and_map(n_intervals):
    df = update_data()
    dropdown_options = [{'label': date, 'value': date} for date in df['date']]
    if not df.empty:
        initial_value = df['date'].iloc[0]
    else:
        initial_value = None

    custom_colors = [
        "#006400",  # Green
        "#00FF00",  # Lime
        "#ffbf00",  # Yellow
        "#ff4000",  # Orange
        "#ff0000",  # Red
    ]
    fig = px.scatter_mapbox(df,
                            lat='latitude',
                            lon='longitude',
                            hover_name='title',
                            hover_data=['intensity', 'location'],
                            color=df['scale'],
                            color_continuous_scale=custom_colors,
                            range_color=[1, 10],
                            size=df['scale'],
                            size_max=10,
                            zoom=4.4,
                            center=dict(lat=37.200, lon=-18.000))
    fig.update_layout(mapbox_style="open-street-map")
    fig.update_layout(margin={"r": 0, "t": 0, "l": 0, "b": 0})

    return dropdown_options, initial_value, fig

# Callback to update description and publication date
@app.callback(
    Output('description-date', 'children'),
    [Input('title-dropdown', 'value')]
)
def update_description_data(selected_date):
    df = update_data()
    row = df[df['date'] == selected_date]
    if not row.empty:
        description = html.Table(
            style={"text-align": "left", "font-size":"15px"},
            children=[
                html.Tr([html.Th("Hora: "), html.Td(row['date'])]),
                html.Tr([html.Th("Epicentro: "), html.Td(row['location'])]),
                html.Tr([html.Th("Intensidade (MMI): "), html.Td(row['intensity'])]),
                html.Tr([html.Th("Magnitude: "), html.Td(row['scale'])])
            ])
        return description
    else:
        return html.Div("No data available")

if __name__ == '__main__':
    app.run_server(debug=False)
